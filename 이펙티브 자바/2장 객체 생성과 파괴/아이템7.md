# 아이템7 다 쓴 객체 참조를 해제하라
## 다 쓴 참조
* 다 쓴 참조란 다시 쓰지 않을 참조를 뜻한다 .예를 들어 stack에서 꺼내진 객체는 사라지는 것이 아니라 다 쓴 객체 참조로 남아있다.
* 이는 소량의 스택이라면 크게 문제가 되지 않겠지만 프로그램이 오래 실행 되어 stack에 많은 객체들이 쌓일 경우 엄청난 메모리 누수가 생긴다.
* 가비지 컬렉션 언어에서는(의도치 않게 객체를 살려주는) 메모리 누수를 찾기 어렵기 때문에 단 몇 갱의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있어 성능에 굉장한 영향을 미칠 수 있다.
## 다 쓴 참조를 해제하자
* 이러한 문제를 해결할 방법은 해당 참조를 다 썼을 경우 null처리하면 참조해제가 된다.
* null 처리를 하면 만약 클라이언트가 해당 객체를 사용하려하면 NPE가 발생하여 오류를 빨리 발견할 수도 있다.
* 그러나 객체를 다 쓰자마자 null 처리하는 것은 바람직하지 않고 오히려 코드가 지저분 해진다.
## 그러면 언제 null 처리를 해야 할까?
* 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
* 따라서 메모리를 직접 관리하는 클래스는 메모리 누수를 조심해야 한다.
* 예를 들어 stack 구현체처럼 elements라는 배열을 관리하는 경우 가비지 컬렉터는 어떤 객체가 필요하고 필요없는지 모른다.
* 따라서 해당 레퍼런스를 null 처리하여 가비지 컬렉터에게 필요없는 객체들이라 알려야 한다.
## 캐시를 사용할 때 메모리 누수를 조심하자
* 캐시를 사용할 때도 메모리 누수 문제를 조심해야 한다. 객체의 레퍼런스를 캐시에 넣어 놓고, 캐시를 비우는 것을 잊기 쉽다.
* 여러 가지 해결책이 있지만, 캐시의 키에 대한 레퍼런스가 캐시 밖에서 필요 없어지면 해당 엔트리를 캐시에서 자동으로 비워주는 WeakHashMap을 쓸 수 있다.
* 캐시 구현의 안 좋은 예 - 객체를 다 쓴 뒤로도 key를 정리하지 않음.
```java
public class CacheSample {
public static void main(String[] args) {
Object key = new Object();
Object value = new Object();

		Map<Object, List> cache = new HashMap<>();
		cache.put(key, value);
		...
	}
}
```
key의 사용이 없어지더라도 cache가 key의 레퍼런스를 가지고 있으므로, GC의 대상이 될 수 없다.
## 캐시를 사용하고 싶다면 WeakHashMap을 이용하라
* 캐시 외부에서 key를참조하는 동안만 엔트리가 살아있는 캐시가 필요하다면 WeakHashMap을 이용한다.
* 다 쓴 엔트리는 그 즉시 자동으로 제거된다. 단, WeakHashMap은 이런 상황에서만 유용하다.
```java
public class CacheSample {
public static void main(String[] args) {
Object key = new Object();
Object value = new Object();

		Map<Object, List> cache = new WeakHashMap<>();
		cache.put(key, value);
		...
	}
}

```
캐시 값이 무의미해진다면 자동으로 처리해주는 WeakHashMap은 key 값을 모두 Weak 레퍼런스로 감싸 hard reference가 없어지면 GC의 대상이 된다.
즉, WeakHashMap을 사용할 때 key 레퍼런스가 쓸모 없어졌다면, (key - value) 엔트리를 GC의 대상이 되도록해 캐시에서 자동으로 비워준다.

또는 시간이 지나면 캐시값이 의미가 없어지는 경우에 백그라운드 쓰레드를 사용하거나 (ScheduledThreadPoolExecutor), 새로운 엔트리를 추가할 때 부가적인 작업으로 기존 캐시를 비우는 일을 할 것이다. (LinkedHashMap 클래스는 removeEldestEntry라는 메서드를 제공한다.)
## 콜백, 메모리 누수의 주범
* 세번째로 흔하게 메모리 누수가 발생할 수 있는 지점으로 리스너와 콜백이 있다.
* 클라이언트 코드가 콜백을 등록할 수 있는 API를 만들고 콜백을 뺼 수 있는 방법을 제공하지 않는다면, 계속해서 콜백이 쌓이기만 할 것이다. 이것 역시 WeakHashMap을 사용해서 콜백을 Weak 레퍼런스로 저장하면 GC가 이를 즉시 수거해 해결할 수 있다.
ex) WeakHashMap에 키로 저장하면 된다.
## 결론
메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.